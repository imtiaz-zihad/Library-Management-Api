import { fixRemoveArrayElement } from "eslint-fix-utils";
import { createRule } from "../createRule.js";
import { isJSONStringLiteral, isNotNullish } from "../utils/predicates.js";
const defaultFiles = [
  /* cspell:disable-next-line */
  /^(\.\/)?LICEN(C|S)E(\.|$)/i,
  /^(\.\/)?README(\.|$)/i,
  /^(\.\/)?package\.json$/i
];
const wildcardsRegex = /[*?[\]{}]/;
const cachedRegex = /* @__PURE__ */ new Map();
const getCachedLocalFileRegex = (filename) => {
  if (wildcardsRegex.test(filename)) {
    return null;
  }
  const baseFilename = filename.replace("./", "");
  let regex = cachedRegex.get(baseFilename);
  if (regex) {
    return regex;
  } else {
    regex = new RegExp(`^(./)?${baseFilename}$`, "i");
    cachedRegex.set(baseFilename, regex);
    return regex;
  }
};
const rule = createRule({
  create(context) {
    const entryCache = { bin: [], files: [] };
    const report = (elements, index, messageId) => {
      const element = elements[index];
      if (isNotNullish(element) && isJSONStringLiteral(element)) {
        context.report({
          data: { file: element.value },
          messageId,
          node: element,
          suggest: [
            {
              fix: fixRemoveArrayElement(
                context,
                index,
                elements
              ),
              messageId: "remove"
            }
          ]
        });
      }
    };
    return {
      "Program > JSONExpressionStatement > JSONObjectExpression > JSONProperty[key.value=bin]"(node) {
        const binValue = node.value;
        if (isJSONStringLiteral(binValue)) {
          entryCache.bin.push(binValue.value);
        } else if (binValue.type === "JSONObjectExpression") {
          for (const prop of binValue.properties) {
            if (isJSONStringLiteral(prop.value)) {
              entryCache.bin.push(prop.value.value);
            }
          }
        }
      },
      "Program > JSONExpressionStatement > JSONObjectExpression > JSONProperty[key.value=files]"(node) {
        if (node.value.type === "JSONArrayExpression") {
          const seen = /* @__PURE__ */ new Set();
          const elements = node.value.elements;
          entryCache.files = elements;
          for (const [index, element] of elements.entries()) {
            if (isNotNullish(element) && isJSONStringLiteral(element)) {
              if (seen.has(element.value)) {
                report(elements, index, "duplicate");
              } else {
                seen.add(element.value);
              }
              for (const defaultFile of defaultFiles) {
                if (defaultFile.test(element.value)) {
                  report(
                    elements,
                    index,
                    "unnecessaryDefault"
                  );
                }
              }
            }
          }
        }
      },
      "Program > JSONExpressionStatement > JSONObjectExpression > JSONProperty[key.value=main]"(node) {
        if (isJSONStringLiteral(node.value)) {
          entryCache.main = node.value.value;
        }
      },
      "Program:exit"() {
        const files = entryCache.files;
        if (files.length === 0) {
          return;
        }
        const validations = [
          // First check if the "main" entry is included in "files".
          {
            files: entryCache.main ? [entryCache.main] : [],
            messageId: "unnecessaryMain"
          },
          // Next check if any "bin" entries are included in "files".
          {
            files: entryCache.bin,
            messageId: "unnecessaryBin"
          }
        ];
        for (const validation of validations) {
          for (const fileToCheck of validation.files) {
            for (const [index, fileEntry] of files.entries()) {
              if (isNotNullish(fileEntry) && isJSONStringLiteral(fileEntry)) {
                const regex = getCachedLocalFileRegex(
                  fileEntry.value
                );
                if (regex?.test(fileToCheck)) {
                  report(files, index, validation.messageId);
                }
              }
            }
          }
        }
      }
    };
  },
  meta: {
    docs: {
      category: "Best Practices",
      description: "Prevents adding unnecessary / redundant files.",
      recommended: false
    },
    hasSuggestions: true,
    messages: {
      duplicate: 'Files has more than one entry for "{{file}}".',
      remove: "Remove this redundant entry.",
      unnecessaryBin: `Explicitly declaring "{{file}}" in "files" is unnecessary; it's included in "bin".`,
      unnecessaryDefault: `Explicitly declaring "{{file}}" in "files" is unnecessary; it's included by default.`,
      unnecessaryMain: `Explicitly declaring "{{file}}" in "files" is unnecessary; it's the "main" entry.`
    },
    schema: [],
    type: "suggestion"
  }
});
export {
  rule
};
