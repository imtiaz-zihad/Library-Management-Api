import semver from "semver";
import { createRule } from "../createRule.js";
import { isJSONStringLiteral } from "../utils/predicates.js";
const DEPENDENCY_TYPES = [
  "dependencies",
  "devDependencies",
  "optionalDependencies",
  "peerDependencies"
];
const RANGE_TYPES = ["caret", "pin", "tilde"];
const schemaOptions = {
  additionalProperties: false,
  properties: {
    forDependencyTypes: {
      items: {
        enum: DEPENDENCY_TYPES
      },
      type: "array"
    },
    forPackages: {
      items: {
        type: "string"
      },
      type: "array"
    },
    forVersions: {
      type: "string"
    },
    rangeType: {
      oneOf: [
        {
          enum: RANGE_TYPES
        },
        {
          items: {
            enum: RANGE_TYPES
          },
          type: "array"
        }
      ]
    }
  },
  required: ["rangeType"],
  type: "object"
};
const SYMBOLS = {
  caret: "^",
  pin: "",
  tilde: "~"
};
const changeVersionRange = (version, rangeType) => {
  if (/^workspace:[~^*]$/.test(version)) {
    switch (rangeType) {
      case "caret":
        return "workspace:^";
      case "pin":
        return "workspace:*";
      case "tilde":
      default:
        return "workspace:~";
    }
  }
  return version.replace(
    /^(workspace:)?(\^|~|<=?|>=?)?/,
    `$1${SYMBOLS[rangeType]}`
  );
};
const isVersionSupported = (version) => {
  if (/^workspace:[*^~]$/.test(version)) {
    return true;
  }
  const rawVersion = version.replace(/^workspace:/, "");
  return !!semver.validRange(rawVersion);
};
const capitalize = (str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
};
const rule = createRule({
  create(context) {
    if (!context.options[0]) {
      return {};
    }
    const optionsProvided = Array.isArray(context.options[0]) ? [...context.options[0]].reverse() : [context.options[0]];
    const optionsArray = optionsProvided.map((option) => ({
      ...option,
      forPackages: option.forPackages?.map(
        (pattern) => new RegExp(pattern)
      ),
      rangeTypes: Array.isArray(option.rangeType) ? option.rangeType : [option.rangeType]
    }));
    return {
      "Program > JSONExpressionStatement > JSONObjectExpression > JSONProperty[key.type=JSONLiteral][value.type=JSONObjectExpression]"(node) {
        const dependencyType = node.key.value;
        if (!DEPENDENCY_TYPES.includes(dependencyType)) {
          return;
        }
        for (const property of node.value.properties) {
          if (!isJSONStringLiteral(property.key) || !isJSONStringLiteral(property.value)) {
            continue;
          }
          const name = property.key.value;
          const version = property.value.value;
          if (!isVersionSupported(version)) {
            continue;
          }
          const isPinned = !!semver.parse(version) || version === "workspace:*";
          const isTildeRange = !!semver.validRange(version) && version.startsWith("~") || version.startsWith("workspace:~");
          const isCaretRange = !!semver.validRange(version) && version.startsWith("^") || version.startsWith("workspace:^");
          for (const options of optionsArray) {
            if (options.forDependencyTypes && !options.forDependencyTypes.includes(dependencyType)) {
              continue;
            }
            if (options.forPackages) {
              const isMatch = options.forPackages.some(
                (packageNameRegex) => packageNameRegex.test(name)
              );
              if (!isMatch) {
                continue;
              }
            }
            if (options.forVersions && // We can't determine whether any workspace version without a numeric version to accompany it, matches this range
            // so we'll just skip it.
            (/^workspace:[^~*]?$/.test(version) || // * matches all
            version !== "*" && !semver.satisfies(
              version.replace(
                /(?:workspace:)?[^~]?/,
                ""
              ),
              options.forVersions
            ))) {
              continue;
            }
            const rangeTypes = options.rangeTypes;
            if (version === "*") {
              context.report({
                data: {
                  rangeTypes: rangeTypes.join(", ")
                },
                messageId: "wrongRangeType",
                node: property.value
              });
              break;
            }
            const rangeTypeMatch = rangeTypes.find((rangeType) => {
              switch (rangeType) {
                case "caret":
                  return isCaretRange;
                case "pin":
                  return isPinned;
                case "tilde":
                  return isTildeRange;
              }
            });
            if (!rangeTypeMatch) {
              context.report({
                data: {
                  rangeTypes: rangeTypes.join(", ")
                },
                messageId: "wrongRangeType",
                node: property.value,
                suggest: rangeTypes.map((rangeType) => ({
                  fix(fixer) {
                    return fixer.replaceText(
                      property.value,
                      `"${changeVersionRange(version, rangeType)}"`
                    );
                  },
                  messageId: `changeTo${capitalize(rangeType)}`
                }))
              });
            }
            break;
          }
        }
      }
    };
  },
  meta: {
    docs: {
      description: "Restricts the range of dependencies to allow or disallow specific types of ranges."
    },
    hasSuggestions: true,
    messages: {
      changeToCaret: "Change to use a caret range.",
      changeToPin: "Pin the version.",
      changeToTilde: "Change to use a tilde range.",
      wrongRangeType: "This dependency is using the wrong range type.  Acceptable range type(s): {{rangeTypes}}"
    },
    schema: [
      {
        oneOf: [
          schemaOptions,
          {
            items: schemaOptions,
            type: "array"
          }
        ]
      }
    ],
    type: "suggestion"
  }
});
export {
  rule
};
